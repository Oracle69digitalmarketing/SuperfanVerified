import passport from 'passport';import { Strategy as SpotifyStrategy } from 'passport-spotify';import { Strategy as GoogleStrategy } from 'passport-google-oauth20';import { Strategy as FacebookStrategy } from 'passport-facebook';import { Strategy as TwitterStrategy } from 'passport-twitter';import User from '../models/User.js'; // ensure correct relative path// ===== HANDLER =====async function handleUser(profile, accessToken, refreshToken, provider, done) {  try {    let email = profile.emails?.[0]?.value || null;    let user = await User.findOne({ provider, providerId: profile.id });    if (!user) {      user = await User.create({        provider,        providerId: profile.id,        displayName: profile.displayName || profile.username,        email,        accessToken,        refreshToken,        profile,      });    } else {      user.accessToken = accessToken;      user.refreshToken = refreshToken;      await user.save();    }    return done(null, user);  } catch (err) {    return done(err, null);  }}// ===== STRATEGIES =====if (!process.env.SPOTIFY_CLIENT_ID || !process.env.SPOTIFY_CLIENT_SECRET) {  console.error('Spotify client ID or secret is missing!');}passport.use(  new SpotifyStrategy(    {      clientID: process.env.SPOTIFY_CLIENT_ID,      clientSecret: process.env.SPOTIFY_CLIENT_SECRET,      callbackURL: process.env.SPOTIFY_CALLBACK_URL,    },    (accessToken, refreshToken, expires_in, profile, done) =>      handleUser(profile, accessToken, refreshToken, 'spotify', done)  ));passport.use(  new GoogleStrategy(    {      clientID: process.env.GOOGLE_CLIENT_ID,      clientSecret: process.env.GOOGLE_CLIENT_SECRET,      callbackURL: process.env.GOOGLE_CALLBACK_URL,    },    (accessToken, refreshToken, profile, done) => handleUser(profile, accessToken, refreshToken, 'google', done)  ));passport.use(  new FacebookStrategy(    {      clientID: process.env.FACEBOOK_APP_ID,      clientSecret: process.env.FACEBOOK_APP_SECRET,      callbackURL: process.env.FACEBOOK_CALLBACK_URL,      profileFields: ['id', 'displayName', 'emails'],    },    (accessToken, refreshToken, profile, done) => handleUser(profile, accessToken, refreshToken, 'facebook', done)  ));passport.use(  new TwitterStrategy(    {      consumerKey: process.env.TWITTER_CONSUMER_KEY,      consumerSecret: process.env.TWITTER_CONSUMER_SECRET,      callbackURL: process.env.TWITTER_CALLBACK_URL,    },    (accessToken, refreshToken, profile, done) => handleUser(profile, accessToken, refreshToken, 'twitter', done)  ));// ===== SESSIONS =====passport.serializeUser((user, done) => done(null, user._id));passport.deserializeUser(async (id, done) => {  try {    const user = await User.findById(id);    done(null, user);  } catch (err) {    done(err, null);  }});export default passport;